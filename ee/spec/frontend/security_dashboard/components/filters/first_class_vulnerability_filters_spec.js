import VueRouter from 'vue-router';
import { createLocalVue, shallowMount } from '@vue/test-utils';
import { initFirstClassVulnerabilityFilters, scannerFilter } from 'ee/security_dashboard/helpers';
import Filters from 'ee/security_dashboard/components/filters/first_class_vulnerability_filters.vue';
import Filter from 'ee/security_dashboard/components/filters/filter.vue';
import ScannerFilterComponent from 'ee/security_dashboard/components/filters/scanner_filter.vue';

const router = new VueRouter();
const localVue = createLocalVue();
localVue.use(VueRouter);

describe('First class vulnerability filters component', () => {
  let wrapper;
  let filters;

  const projects = [
    { id: 'gid://gitlab/Project/11', name: 'GitLab Org' },
    { id: 'gid://gitlab/Project/12', name: 'GitLab Com' },
  ];

  const findScannerFilter = () => wrapper.find(ScannerFilterComponent);
  const findFilters = () => wrapper.findAll(Filter);
  const findStateFilter = () => findFilters().at(0);
  const findSeverityFilter = () => findFilters().at(1);
  const findProjectFilter = () => findFilters().at(2);
  const findLastFilter = () => findFilters().at(filters.length - 1);

  const createComponent = ({ propsData, listeners } = {}) => {
    return shallowMount(Filters, { localVue, router, propsData, listeners });
  };

  afterEach(() => {
    wrapper.destroy();
    wrapper = null;
  });

  describe('on render without project filter', () => {
    beforeEach(() => {
      wrapper = createComponent();
      filters = initFirstClassVulnerabilityFilters();
    });

    it('should render the filters', () => {
      expect(findFilters()).toHaveLength(filters.length);
    });

    it('should emit the setFilter event when setting a filter', () => {
      const stub = jest.fn();
      const options = { foo: 'bar' };

      wrapper.setMethods({ setFilter: stub });
      findStateFilter().vm.$emit('filterChange', options);

      expect(stub).toHaveBeenCalledWith(options);
    });
  });

  describe('when project filter is populated dynamically', () => {
    beforeEach(() => {
      filters = initFirstClassVulnerabilityFilters([]);
      wrapper = createComponent({ propsData: { projects: [] } });
    });

    it('should render the project filter with one option', () => {
      expect(findLastFilter().props('filter')).toEqual({
        id: 'projectId',
        name: 'Project',
        options: [{ id: 'all', name: 'All projects' }],
        selection: new Set(['all']),
      });
    });

    it('should set the projects dynamically', () => {
      wrapper.setProps({ projects });
      return wrapper.vm.$nextTick(() => {
        expect(findLastFilter().props('filter')).toEqual(
          expect.objectContaining({
            options: [
              { id: 'all', name: 'All projects' },
              { id: '11', name: 'GitLab Org' },
              { id: '12', name: 'GitLab Com' },
            ],
          }),
        );
      });
    });
  });

  describe('when project filter is ready on mount', () => {
    beforeEach(() => {
      filters = initFirstClassVulnerabilityFilters([]);
      wrapper = createComponent({ propsData: { projects } });
    });

    it('should set the projects dynamically', () => {
      expect(findLastFilter().props('filter')).toEqual(
        expect.objectContaining({
          options: [
            { id: 'all', name: 'All projects' },
            { id: '11', name: 'GitLab Org' },
            { id: '12', name: 'GitLab Com' },
          ],
        }),
      );
    });
  });

  describe('when no filter is persisted in the URL', () => {
    beforeEach(() => {
      wrapper = createComponent({
        propsData: { projects },
      });
    });

    it('should redirect the user to an updated the URL and default the filters to CONFIRMED + DETECTED state', () => {
      expect(findStateFilter().props('filter')).toEqual(
        expect.objectContaining({
          selection: new Set(['DETECTED', 'CONFIRMED']),
        }),
      );
    });
  });

  describe('standard filters', () => {
    describe.each`
      filter         | value                   | selector
      ${'state'}     | ${'DETECTED,DISMISSED'} | ${findStateFilter}
      ${'severity'}  | ${'MEDIUM'}             | ${findSeverityFilter}
      ${'projectId'} | ${'12'}                 | ${findProjectFilter}
    `('when filters are persisted', ({ filter, value, selector }) => {
      describe(`with filter set to ${filter}: ${value}`, () => {
        let filterChangeSpy;

        beforeEach(() => {
          filterChangeSpy = jest.fn();

          wrapper = createComponent({
            propsData: { projects },
            listeners: { filterChange: filterChangeSpy },
          });

          router.push({ query: { [filter]: value.split(',') } }, () => {});
        });

        it(`should have the ${filter} filter as pre-selected`, () => {
          expect(selector().props('filter').selection).toEqual(new Set(value.split(',')));
        });

        it('should emit a filterChange event', () => {
          expect(wrapper.emitted().filterChange).toBeTruthy();
        });

        it('should not trigger the filterChange additonally when the filters do not change', () => {
          router.push({
            query: {
              ...wrapper.vm.$route.query,
              'some-unrelated-query-param': 'true',
            },
          });

          return wrapper.vm.$nextTick(() => {
            expect(filterChangeSpy).toHaveBeenCalledTimes(1);
          });
        });

        it('should trigger the filterChange when the filters are reset', () => {
          router.push({ query: {} });

          return wrapper.vm.$nextTick(() => {
            expect(filterChangeSpy).toHaveBeenNthCalledWith(2, {});
          });
        });

        it('should reset the filters when the URL contains no more filters', () => {
          router.push({ query: {} });

          return wrapper.vm.$nextTick(() => {
            expect(selector().props('filter').selection).toEqual(new Set(['all']));
          });
        });
      });
    });

    describe.each`
      filter         | selector              | index
      ${'state'}     | ${findStateFilter}    | ${0}
      ${'severity'}  | ${findSeverityFilter} | ${1}
      ${'projectId'} | ${findProjectFilter}  | ${2}
    `('when setFilter is called', ({ filter, selector, index }) => {
      describe(filter, () => {
        let filterId;
        let optionId;
        let routePushSpy;

        beforeEach(() => {
          filters = initFirstClassVulnerabilityFilters(projects);
          filterId = filters[index].id;
          optionId = filters[index].options[1].id;
          filters[index].selection = new Set([optionId]);
          wrapper = createComponent({ propsData: { projects } });
          routePushSpy = jest.spyOn(router, 'push');
          selector().vm.$emit('filter-change', filters);
        });

        afterEach(() => {
          // This will reset the query state
          router.push('/');
        });

        it('should emit a filterChange event', async () => {
          expect(wrapper.emitted().filterChange).toBeTruthy();
        });

        it('should update the path', () => {
          expect(routePushSpy).toHaveBeenCalledWith({
            query: { [filterId]: [optionId] },
          });
        });
      });
    });
  });

  describe('scanner filter', () => {
    describe('when filters are persisted with filter set to reportType: SAST_GitLab', () => {
      let filterChangeSpy;

      beforeEach(() => {
        filterChangeSpy = jest.fn();

        wrapper = createComponent({
          propsData: { projects },
          listeners: { filterChange: filterChangeSpy },
        });

        router.push({ query: { scanner: ['SAST_GitLab'] } }, () => {});
      });

      it(`should have the reportType filter as pre-selected`, () => {
        expect(wrapper.emitted().filterChange).toBeTruthy();
        expect(findScannerFilter().props('filter').selection).toEqual(new Set(['SAST_GitLab']));
      });

      it('should not trigger the filterChange additonally when the filters do not change', async () => {
        router.push({
          query: {
            ...wrapper.vm.$route.query,
            'some-unrelated-query-param': 'true',
          },
        });

        await wrapper.vm.$nextTick;
        expect(filterChangeSpy).not.toHaveBeenCalled();
      });

      it('should trigger the filterChange when the filters are reset', async () => {
        // TODO: FIX
        router.push({ query: {} });
        await wrapper.vm.$nextTick;
        expect(filterChangeSpy).toHaveBeenNthCalledWith(2, {});
      });

      it('should reset the filters when the URL contains no more filters', async () => {
        // TODO: FIX
        router.push({ query: {} });
        await wrapper.vm.$nextTick;
        expect(findScannerFilter().props('filter').selection).toEqual(new Set(['all']));
      });
    });

    describe('when setFilter is called', () => {
      let filterId;
      let optionId;
      let routePushSpy;

      beforeEach(() => {
        const newScannerFilter = { ...scannerFilter };
        filterId = scannerFilter.id;
        optionId = scannerFilter.options[1].id;
        newScannerFilter.selection = new Set([optionId]);
        wrapper = createComponent({ propsData: { projects } });
        routePushSpy = jest.spyOn(router, 'push');
        findScannerFilter().vm.$emit('filter-change', [newScannerFilter]);
      });

      afterEach(() => {
        // This will reset the query state
        router.push('/');
      });

      it('should emit a filterChange event', () => {
        expect(wrapper.emitted().filterChange).toBeTruthy();
      });

      it('should update the path', () => {
        expect(routePushSpy).toHaveBeenCalledWith({
          query: { [filterId]: [optionId] },
        });
      });
    });
  });
});
